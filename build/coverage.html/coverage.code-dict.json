{"/home/travis/build/npmtest/node-npmtest-autodoc/test.js":"/* istanbul instrument in package npmtest_autodoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autodoc/lib.npmtest_autodoc.js":"/* istanbul instrument in package npmtest_autodoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_autodoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_autodoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-autodoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-autodoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_autodoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_autodoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_autodoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_autodoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_autodoc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_autodoc.__dirname + '/lib.npmtest_autodoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autodoc/node_modules/autodoc/autodoc-node.js":"var Autodoc = require('./autodoc'),\n    Lazy    = require('lazy.js');\n\nAutodoc.options.codeParser      = require('esprima');\nAutodoc.options.commentParser   = require('doctrine');\nAutodoc.options.markdownParser  = require('marked');\nAutodoc.options.templateEngine  = require('mustache');\nAutodoc.options.highlighter     = require('codemirror-highlight');\n\nAutodoc.options.compiler = {\n  'javascript': {\n    compile: function(source) {\n      return source;\n    }\n  },\n\n  'coffeescript': (function(compiler) {\n\n    function compile(source, options) {\n      var js = compiler.compile(source, options);\n\n      // Basically we want to eliminate blank lines after block comments so that\n      // Autodoc can do the whole associate-doclets-with-functions thing. I'm\n      // not sure if this is the best approach, but it feels better than having\n      // more logic in autodoc.js to handle varying amounts of space between\n      // comments and functions for different languages. (Though there is a not-\n      // super-unlikely chance that I will completely reverse my opinion on\n      // this.)\n      var justAfterComment = false;\n      var lines = Lazy(js).split('\\n').filter(function(line) {\n        if ((/^\\s*$/).test(line) && justAfterComment) {\n          return false;\n        }\n\n        justAfterComment = false;\n        if ((/^\\s*\\*\\//).test(line)) {\n          justAfterComment = true;\n        }\n\n        return true;\n      });\n\n      return lines.join('\\n');\n    }\n\n    return { compile: compile };\n\n  }(require('coffee-script')))\n};\n\nmodule.exports = Autodoc;\n","/home/travis/build/npmtest/node-npmtest-autodoc/node_modules/autodoc/autodoc.js":"/**\n * Autodoc helps eliminate a lot of the gruntwork involved in creating a\n * JavaScript project. In particular it simplifies **writing and executing\n * tests**, **running performance benchmarks**, and **generating API\n * documentation**.\n */\n(function(context) {\n\n  var Lazy      = context.Lazy,\n      Spiderman = context.Spiderman;\n\n  // Auto-require dependencies if they aren't already defined and we're in Node.\n  if (typeof Lazy === 'undefined' && typeof require === 'function') {\n    Lazy = require('lazy.js');\n  }\n  if (typeof Spiderman === 'undefined' && typeof require === 'function') {\n    Spiderman = require('spiderman');\n  }\n\n  /**\n   * An object responsible for parsing source code into an AST.\n   *\n   * @typedef {Object} Parser\n   * @property {function(string):*} parse\n   */\n\n  /**\n   * @typedef {Object} ExampleHandler\n   * @property {RegExp} pattern\n   * @property {function(Array.<string>, *):*} test\n   */\n\n  /**\n   * An object responsible for rendering HTML templates. Autodoc currently\n   * assumes a decidedly Mustache-like engine. Maybe someday this will be more\n   * abstract, with adapters and whatnot.\n   *\n   * @typedef {Object} TemplateEngine\n   * @property {function(string, Object):string} render\n   */\n\n  /**\n   * All of the options Autodoc supports.\n   *\n   * @typedef {Object} AutodocOptions\n   * @property {Parser|function(string):*} codeParser\n   * @property {Parser|function(string):*} commentParser\n   * @property {Parser|function(string):*} markdownParser\n   * @property {Array.<string>} namespaces\n   * @property {Array.<string>} tags\n   * @property {string} grep\n   * @property {Array.<string>} javascripts\n   * @property {string} template\n   * @property {TemplateEngine} templateEngine\n   * @property {Object.<string, string>} templatePartials\n   * @property {Array.<ExampleHandler>} exampleHandlers\n   * @property {Object} extraOptions\n   */\n\n  /**\n   * @constructor\n   * @param {AutodocOptions=} options\n   */\n  function Autodoc(options) {\n    options = Lazy(options || {})\n      .defaults(Autodoc.options)\n      .toObject();\n\n    this.codeParser       = wrapParser(options.codeParser);\n    this.commentParser    = wrapParser(options.commentParser);\n    this.markdownParser   = wrapParser(options.markdownParser, Autodoc.processInternalLinks);\n    this.highlighter      = options.highlighter;\n    this.language         = options.language || 'javascript';\n    this.compiler         = options.compiler[this.language];\n    this.namespaces       = options.namespaces || [];\n    this.tags             = options.tags || [];\n    this.grep             = options.grep;\n    this.javascripts      = options.javascripts || [];\n    this.exampleHandlers  = exampleHandlers(options.exampleHandlers);\n    this.template         = options.template;\n    this.templateEngine   = options.templateEngine;\n    this.templatePartials = options.templatePartials;\n    this.extraOptions     = options.extraOptions || {};\n    this.errors           = [];\n\n    if (this.highlighter) {\n      this.highlighter.loadMode(this.language);\n    }\n  }\n\n  Autodoc.VERSION = '0.6.4';\n\n  /**\n   * Default Autodoc options. (See autodoc-node.js)\n   */\n  Autodoc.options = {};\n\n  /**\n   * Represents an error encountered by Autodoc.\n   *\n   * @public @typedef {Object} ErrorInfo\n   * @property {string} stage\n   * @property {string} message\n   * @property {number} line\n   */\n\n  /**\n   * An object describing a library, including its namespaces and custom types\n   * as well as private/internal members.\n   *\n   * @public @typedef {Object} LibraryInfo\n   * @property {string} name\n   * @property {string} referenceName\n   * @property {string} description\n   * @property {string} code\n   * @property {Array.<NamespaceInfo>} namespaces\n   * @property {boolean} hasTypes\n   * @property {Array.<TypeInfo>} types\n   * @property {Array.<FunctionInfo>} privateMembers\n   * @property {string} exampleHelpers\n   * @property {Array.<ErrorInfo>} errors\n   */\n\n  /**\n   * Creates a Autodoc instance with the specified options and uses it to\n   * parse the given code.\n   *\n   * @public\n   * @param {string} code The JavaScript code to parse.\n   * @param {AutodocOptions=} options\n   * @returns {LibraryInfo}\n   */\n  Autodoc.parse = function(code, options) {\n    return new Autodoc(options).parse(code);\n  };\n\n  /**\n   * Creates a Autodoc instance with the specified options and uses it to\n   * generate HTML documentation from the given code.\n   *\n   * @public\n   * @param {LibraryInfo|string} source Either the already-parsed library data\n   *     (from calling {@link #parse}), or the raw source code.\n   * @param {AutodocOptions} options\n   * @returns {string} The HTML for the library's API docs.\n   */\n  Autodoc.generate = function(source, options) {\n    return new Autodoc(options).generate(source);\n  };\n\n  /**\n   * Parses an arbitrary blob of JavaScript code and returns an object\n   * containing all of the data necessary to generate a project website with\n   * docs, specs, and performance benchmarks.\n   *\n   * @param {string} code The JavaScript code to parse.\n   * @returns {LibraryInfo}\n   */\n  Autodoc.prototype.parse = function(code) {\n    var autodoc = this;\n\n    // Compile the input code into something codeParser can parse. (For\n    // JavaScript, this should just spit the same code right back out. For\n    // CoffeeScript, it will compile it to JS then do a bit of post-processing\n    // on it to ensure our AST-traversal and doclet-grouping stuff all still\n    // works.)\n    code = this.compiler.compile(code);\n\n    // Generate the abstract syntax tree.\n    var ast = this.codeParser.parse(code, {\n      comment: true,\n      loc: true,\n      range: true\n    });\n\n    // This is kind of stupid... for now, I'm just assuming the library will\n    // have a @fileOverview tag and @name tag in the header comments.\n    var librarySummary = autodoc.getLibrarySummary(ast.comments);\n\n    // Extract all of the functions from the AST, and map them to their location\n    // in the code (this is so that we can associate each function with its\n    // accompanying doc comments, if any).\n    var functionsByLine = Lazy(Spiderman(ast).descendents())\n      .filter(function(node) {\n        return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression';\n      })\n      .groupBy(function(node) { return node.unwrap().loc.start.line; })\n      .map(function(list, line) { return [line, list[0]]; })\n      .toObject();\n\n    // Go through all of of the comments in the AST, attempting to associate\n    // each with a function.\n    var functions = Lazy(ast.comments)\n      .map(function(comment) {\n        // Find the function right after this comment. If none exists, skip it.\n        var fn = functionsByLine[comment.loc.end.line + 1];\n        if (typeof fn === 'undefined') {\n          return null;\n        }\n\n        // Attempt to parse the comment. If it can't be parsed, or it appears to\n        // be basically empty, then skip it.\n        var doc = autodoc.parseComment(comment);\n        if (!doc) {\n          return null;\n        }\n\n        // This will be useful later.\n        comment.lines = comment.value.split('\\n');\n\n        return autodoc.createFunctionInfo(fn, doc, comment, Autodoc.getFunctionSource(fn.unwrap(), code));\n      })\n      .compact()\n      .toArray();\n\n    // Also identify all of the comments that define custom types w/ the\n    // `@typedef` tag.\n    var typeDefs = Lazy(ast.comments)\n      .filter(function(comment) {\n        return (/@typedef\\b/).test(comment.value);\n      })\n      .map(function(comment) {\n        var doc = autodoc.parseComment(comment);\n        if (typeof doc === 'undefined') {\n          return null;\n        }\n\n        if (!Lazy(doc.tags).any({ title: 'typedef' })) {\n          return null;\n        }\n\n        return autodoc.createTypeInfo(doc);\n      })\n      .compact()\n      .toArray();\n\n    // If no tags have been explicitly provided, but we find any occurrences of\n    // the @public tag, we'll use that as a hint that only those methods tagged\n    // @public should be included. Otherwise include everything.\n    if (this.tags.length === 0) {\n      if (Lazy(functions).any('isPublic')) {\n        this.tags.push('public');\n      }\n    }\n\n    // Only include documentation for functions/types with the specified tag(s),\n    // if provided.\n    if (this.tags.length > 0) {\n      Lazy(functions).concat(typeDefs).each(function(functionOrType) {\n        var hasTag = Lazy(autodoc.tags).any(function(tag) {\n          return Lazy(functionOrType.tags).contains(tag);\n        });\n\n        if (!hasTag) {\n          functionOrType.excludeFromDocs = true;\n        }\n      });\n    }\n\n    // Group by namespace so that we can keep the functions organized.\n    var functionsByNamespace = Lazy(functions)\n      .groupBy(function(fn) {\n        return fn.isPrivate ? '[private]' : (fn.namespace || fn.shortName);\n      })\n      .toObject();\n\n    // Only include specified namespaces, if the option has been provided.\n    // Otherwise use all namespaces.\n    if (this.namespaces.length === 0) {\n      this.namespaces = Object.keys(functionsByNamespace).sort();\n    }\n\n    var namespaces = Lazy(this.namespaces)\n      .map(function(namespace) {\n        return Autodoc.createNamespaceInfo(functionsByNamespace, namespace);\n      })\n      .toArray();\n\n    var privateMembers = Lazy(namespaces)\n      .map('privateMembers')\n      .flatten()\n      .reject(function(member) {\n        return !member.shortName;\n      })\n      .toArray();\n\n    Lazy(privateMembers).each(function(member, i) {\n      member.methods = Lazy(functions)\n        .where({ namespace: member.shortName })\n        .toArray();\n    });\n\n    // If there's a line that looks like:\n    //\n    //     module.exports = Foo;\n    //\n    // ...then we'll assume 'Foo' is the \"reference name\" of the library; i.e.,\n    // the name conventionally used to refer to it within other libraries or\n    // applications (like _ for Underscore, $ for jQuery, and so on).\n    var nameFromModuleExports = Lazy(Spiderman(ast).descendents())\n      .map(Autodoc.getModuleExportsIdentifier)\n      .compact()\n      .first();\n\n    var referenceName = nameFromModuleExports;\n\n    // If not, we'll guess that the first \"namespace\" that actually has members\n    // is probably the conventional name.\n    if (!referenceName) {\n      var firstNonEmptyNamespace = Lazy(namespaces)\n        .find(function(namespace) {\n          return namespace.members.length > 0;\n        });\n\n      referenceName = firstNonEmptyNamespace ?\n        firstNonEmptyNamespace.namespace.split('.').shift() :\n        null;\n    }\n\n    // See if there's a comment somewhere w/ the @exampleHelpers tag; if so,\n    // we'll supply that code to all examples.\n    var exampleHelpers = Lazy(ast.comments)\n      .filter(function(comment) {\n        return (/@exampleHelpers\\b/).test(comment.value);\n      })\n      .map(function(comment) {\n        var doc = autodoc.parseComment(comment);\n        if (typeof doc === 'undefined') {\n          return null;\n        }\n\n        return Autodoc.getTagDescriptions(doc, 'exampleHelpers');\n      })\n      .flatten()\n      .compact()\n      .first() || '';\n\n    // TODO: Make this code a little more agnostic about the whole namespace\n    // thing. I'm pretty sure there are plenty of libraries that don't use\n    // this pattern at all.\n    return {\n      name: librarySummary.name || referenceName,\n      referenceName: referenceName,\n      description: librarySummary.description,\n      code: code,\n      namespaces: namespaces,\n      docs: functions,\n      privateMembers: privateMembers,\n      hasTypes: !Lazy(typeDefs).all('excludeFromDocs'),\n      types: typeDefs,\n      exampleHelpers: exampleHelpers,\n      errors: this.errors\n    };\n  };\n\n  /**\n   * Generates HTML for the API docs for the given library (as raw source code)\n   * using the specified options, including templating library.\n   *\n   * @param {LibraryInfo|string} source Either the already-parsed library data\n   *     (from calling {@link #parse}), or the raw source code.\n   * @returns {string} The HTML for the library's API docs.\n   */\n  Autodoc.prototype.generate = function(source) {\n    var libraryInfo = typeof source === 'string' ?\n      this.parse(source) :\n      source;\n\n    // Decorate examples w/ custom handlers so that the template can be\n    // populated differently for them.\n    this.updateExamples(libraryInfo);\n\n    // Additional stuff we want to tack on.\n    libraryInfo.javascripts = this.javascripts;\n\n    // If the grep option was provided, filter out all methods not matching the\n    // specified pattern.\n    var grep = this.grep;\n    if (grep) {\n      grep = new RegExp(grep);\n\n      Lazy(libraryInfo.namespaces).each(function(namespace) {\n        namespace.allMembers = Lazy(namespace.allMembers)\n          .filter(function(member) {\n            return grep.test(member.name);\n          })\n          .toArray();\n\n        namespace.hasExamples = Lazy(namespace.allMembers).any('hasExamples');\n      });\n\n      libraryInfo.docs = Lazy(libraryInfo.docs)\n        .filter(function(member) {\n          return grep.test(member.name)\n        })\n        .toArray();\n    }\n\n    // Allow for arbitrary additional options, e.g. if the user wants to use\n    // a custom template.\n    var templateData = Lazy(libraryInfo)\n      .extend(this.extraOptions)\n      .toObject();\n\n    // Finally pass our awesomely-finessed data to the template engine,\n    // e.g., Mustache.\n    return this.templateEngine.render(this.template, templateData, this.templatePartials);\n  };\n\n  /**\n   * Iterates over all of the examples in the library and applies a callback to\n   * each, along with its associated function name.\n   *\n   * @param {LibraryInfo} libraryInfo\n   * @param {function(ExampleInfo, string):*} callback\n   */\n  Autodoc.prototype.eachExample = function(libraryInfo, callback) {\n    Lazy(libraryInfo.docs)\n      .each(function(doc) {\n        Lazy(doc.examples).pluck('list').flatten().each(function(example) {\n          callback(example, doc.name);\n        });\n      });\n  };\n\n  /**\n   * Iterates over all of the examples in the library and tests whether each\n   * should be handled by a custom handler. If so, marks it as such for\n   * consumption by e.g. a template or a test runner.\n   *\n   * @param {LibraryInfo} libraryInfo\n   */\n  Autodoc.prototype.updateExamples = function(libraryInfo) {\n    // Allow a library to provide a config.js file, which should define an array\n    // of handlers like:\n    //\n    // [\n    //   { pattern: /regex/, test: function(match, actual) },\n    //   { pattern: /regex/, test: function(match, actual) },\n    //   ...\n    // ]\n    //\n    var exampleHandlers = this.exampleHandlers;\n    if (exampleHandlers.length === 0) {\n      return;\n    }\n\n    var templateEngine   = this.templateEngine,\n        templatePartials = this.templatePartials,\n        codeParser       = this.codeParser;\n\n    var brokenExamples = [];\n\n    this.eachExample(libraryInfo, function(example) {\n      // Look at all of our examples. Those that are matched by some handler, we\n      // will leave to be verified by handler.test, which will obviously need to\n      // be available in the output HTML (bin/autodoc ensures this).\n      var matchingHandler = Lazy(exampleHandlers).any(function(handler, i) {\n        var match = example.expected.match(handler.pattern),\n            data;\n\n        if (match) {\n          if (typeof handler.template === 'string') {\n            if (!(handler.template in templatePartials)) {\n              throw 'Template \"' + handler.template + '\" not defined.';\n            }\n\n            data = { match: match };\n\n            if (typeof handler.data === 'function') {\n              data = handler.data(match);\n\n              // Yes, this could potentially override a property like\n              // 'whateverEscaped'... I don't care about that right now. Easy to\n              // fix later.\n              Lazy(Object.keys(data)).each(function(key) {\n                data[key + 'Escaped'] = Autodoc.escapeJsString(data[key]);\n              });\n            }\n\n            example.exampleSource = templateEngine.render(\n              templatePartials[handler.template],\n              Lazy(example).extend(data).toObject()\n            ) || '// pending';\n\n          } else {\n            throw 'Custom example handlers must provide a template name.';\n          }\n\n          // Exit early -- we found our handler!\n          return true;\n        }\n      });\n\n      if (!matchingHandler) {\n        // In case there's no custom handler defined for this example, let's\n        // ensure that it's at least valid JavaScript. If not, that's a good\n        // indicator there SHOULD be a custom handler defined for it!\n        try {\n          codeParser.parse(\n            example.statement + '\\n' +\n            'var expected = ' + example.expected\n          );\n\n        } catch (e) {\n          brokenExamples.push({\n            example: example,\n            error: e\n          });\n        }\n      }\n    });\n\n    if (brokenExamples.length > 0) {\n      console.error(\"\\n\\x1B[33mThe following examples don't match any custom handlers, \" +\n        \"and they aren't valid JavaScript:\\x1B[39m\\n\");\n\n      Lazy(brokenExamples).each(function(data) {\n        var example = data.example,\n            error = data.error;\n\n        var offendingLine = error.lineNumber;\n\n        console.error(withLineNumbers(example.actual + '\\n' + example.expected,\n          example.absoluteLine, offendingLine));\n\n        error = String(error).replace(/Line (\\d+)/, function(match, number) {\n          return 'Line ' + (Number(number) + example.absoluteLine - 1);\n        });\n        console.error('\\x1B[31m' + error + '\\x1B[39m');\n\n        // Mark the example as broken so we don't run it.\n        example.broken = true;\n      });\n\n      console.error(\"\\nYou can define custom handlers in a 'handlers.js' file \" +\n        \"(or specify with the --handlers option), like this:\\n\");\n\n      console.error([\n        'this.exampleHandlers = [',\n        '  {',\n        '    pattern: /pattern to match/',\n        '    template: \"name of template\"',\n        '  }',\n        '  ...',\n        '];'\n      ].join('\\n'));\n\n      console.error('\\nSee the README at ' +\n        '\\x1B[36mhttps://github.com/dtao/autodoc/blob/master/README.md\\x1B[39m ' +\n        'for more details.\\n');\n    }\n  };\n\n  /**\n   * @public\n   * @typedef {Object} FunctionInfo\n   * @property {string} name\n   * @property {string} description\n   * @property {boolean} isConstructor\n   * @property {boolean} isStatic\n   * @property {boolean} isPublic\n   * @property {boolean} isPrivate\n   * @property {boolean} hasSignature\n   * @property {string} signature\n   * @property {string} highlightedSignature\n   * @property {boolean} hasExamples\n   * @property {boolean} hasBenchmarks\n   * @property {Array.<ParameterInfo>} params\n   * @property {Array.<ReturnInfo>} returns\n   * @property {ExampleCollection} examples\n   * @property {BenchmarkCollection} benchmarks\n   * @property {Array.<string>} tags\n   * @property {string} source\n   * @property {string} highlightedSource\n   */\n\n  /**\n   * Takes a function node from the AST along with its associated doclet (from\n   * parsing its comments) and generates an object with boatloads of data on it,\n   * useful for passing to a templating system such as Mustache.\n   *\n   * @param {Object} fn\n   * @param {Object} doc\n   * @param {Object} comment\n   * @param {string} source\n   * @returns {FunctionInfo}\n   */\n  Autodoc.prototype.createFunctionInfo = function(fn, doc, comment, source) {\n    var nameInfo    = Autodoc.parseName(fn.inferName() || '', doc),\n        description = this.parseMarkdown(doc.description),\n        params      = this.getParams(doc),\n        returns     = this.getReturns(doc),\n        aliases     = this.getAliases(doc),\n        isCtor      = Autodoc.hasTag(doc, 'constructor'),\n        isStatic    = nameInfo.name.indexOf('#') === -1, // That's right, hacky smacky\n        isPublic    = Autodoc.hasTag(doc, 'public'),\n        isGlobal    = fn.parent.type === 'Program',\n        isPrivate   = Autodoc.hasTag(doc, 'private'),\n        signature   = Autodoc.getSignature(nameInfo, params),\n        examples    = this.getExamples(doc, comment),\n        benchmarks  = this.getBenchmarks(doc, comment),\n        tags        = Lazy(doc.tags).pluck('title').toArray();\n\n    // Do you guys know what I'm talking about? I don't. -Mitch Hedberg\n    if (nameInfo.name !== nameInfo.shortName) {\n      source = nameInfo.namespace + '.' + nameInfo.shortName + ' = ' + source;\n    }\n\n    return {\n      name: nameInfo.name,\n      shortName: nameInfo.shortName,\n      longName: nameInfo.longName,\n      lowerCaseName: nameInfo.shortName.toLowerCase(),\n      searchName: hyphenate(nameInfo.shortName),\n      acronym: acronym(nameInfo.name),\n      identifier: nameInfo.identifier,\n      namespace: nameInfo.namespace,\n      description: description,\n      params: params,\n      returns: returns,\n      aliases: aliases,\n      isConstructor: isCtor,\n      isGlobal: isGlobal,\n      isStatic: isStatic,\n      isPublic: isPublic,\n      isPrivate: isPrivate,\n      hasSignature: params.length > 0 || !!returns,\n      signature: signature,\n      highlightedSignature: insertSignatureLink(this.highlightCode(signature), nameInfo.identifier),\n      examples: examples,\n      hasExamples: examples.length > 0,\n      benchmarks: benchmarks,\n      hasBenchmarks: benchmarks.length > 0,\n      tags: tags,\n      source: source,\n      highlightedSource: this.highlightCode(source)\n    };\n  };\n\n  /**\n   * @typedef {Object} ParameterInfo\n   * @public\n   * @property {string} name\n   * @property {string} type\n   * @property {string} description\n   */\n\n  /**\n   * Gets an array of { name, type, description } objects representing the\n   * parameters of a function definition.\n   *\n   * @param {Object} doc The doclet for the function.\n   * @param {string=} tagName The name of the tag to find (default: 'param').\n   * @returns {Array.<ParameterInfo>} An array of { name, type, description }\n   *     objects.\n   */\n  Autodoc.prototype.getParams = function(doc, tagName) {\n    var self = this;\n\n    return Lazy(doc.tags)\n      .where({ title: tagName || 'param' })\n      .map(function(tag) {\n        return {\n          name: tag.name,\n          type: Autodoc.formatType(tag.type),\n          description: self.parseMarkdown(tag.description || '')\n        };\n      })\n      .toArray();\n  };\n\n  /**\n   * @typedef {Object} ReturnInfo\n   * @property {string} type\n   * @property {string} description\n   */\n\n  /**\n   * Get a { type, description } object representing the return value of a\n   * function definition.\n   *\n   * @param {Object} doc The doclet for the function.\n   * @returns {ReturnInfo} A { type, description } object.\n   */\n  Autodoc.prototype.getReturns = function(doc) {\n    var returnTag = Lazy(doc.tags).findWhere({ title: 'returns' });\n\n    if (typeof returnTag === 'undefined') {\n      return null;\n    }\n\n    return {\n      type: Autodoc.formatType(returnTag.type),\n      description: this.parseMarkdown(returnTag.description || '')\n    };\n  };\n\n  /**\n   * Gets an array of strings providing the aliases for the function definition.\n   *\n   * @param {Object} doc The doclet for the function.\n   * @returns {Array.<string>} An array of strings representing the function's\n   *     aliases.\n   */\n  Autodoc.prototype.getAliases = function(doc, tagName) {\n    var akaTag = Lazy(doc.tags).findWhere({ title: 'aka' });\n\n    if (typeof akaTag === 'undefined' || !akaTag.description) {\n      return [];\n    }\n\n    return akaTag.description.split(/\\s*,\\s*/);\n  };\n\n  /**\n   * A custom type defined by a library.\n   *\n   * @typedef {object} TypeInfo\n   * @public\n   * @property {string} name\n   * @property {string} description\n   * @property {Array.<PropertyInfo>} properties\n   * @property {Array.<string>} tags\n   */\n\n  /**\n   * A property of a type defined by a {@link TypeInfo} object.\n   *\n   * @typedef {Object} PropertyInfo\n   * @public\n   * @property {string} name\n   * @property {string} type\n   * @property {string} description\n   */\n\n  /**\n   * Get a { name, properties } object representing a type defined w/ the\n   * `@typedef` tag.\n   */\n  Autodoc.prototype.createTypeInfo = function(doc) {\n    var description = doc.description,\n        names       = Autodoc.getTagDescriptions(doc, 'typedef')\n        properties  = this.getParams(doc, 'property'),\n        tags        = Lazy(doc.tags).pluck('title').toArray();\n\n    var name = names[0] || '';\n\n    return {\n      name: name,\n      identifier: 'type-' + name,\n      lowerCaseName: name.toLowerCase(),\n      searchName: hyphenate(name),\n      acronym: acronym(name),\n      description: this.parseMarkdown(description),\n      properties: properties,\n      tags: tags\n    };\n  };\n\n  /**\n   * High-level info about a library, namely its name and a brief description.\n   *\n   * @typedef {Object} LibrarySummary\n   * @property {string} name\n   * @property {string} description\n   */\n\n  /**\n   * Returns a { name, description } object describing an entire library.\n   *\n   * @param {Array.<string>} comments\n   * @returns {LibrarySummary}\n   */\n  Autodoc.prototype.getLibrarySummary = function(comments) {\n    var autodoc = this;\n\n    var docs = Lazy(comments)\n      .map(function(comment) {\n        return autodoc.parseComment(comment);\n      })\n      .compact()\n      .toArray();\n\n    var docWithFileOverview = Lazy(docs)\n      .filter(function(doc) {\n        return Lazy(doc.tags).where({ title: 'fileOverview' }).any();\n      })\n      .first();\n\n    var libraryNameTag,\n        libraryName = '',\n        libraryDesc = '';\n\n    if (docWithFileOverview) {\n      libraryDesc = Lazy(docWithFileOverview.tags).findWhere({ title: 'fileOverview' }).description;\n\n      libraryNameTag = Lazy(docWithFileOverview.tags).findWhere({ title: 'name' });\n      if (libraryNameTag) {\n        libraryName = libraryNameTag.description;\n      }\n\n    } else if (docs.length > 0) {\n      libraryNameTag = Lazy(docs[0].tags).findWhere({ title: 'name' });\n      if (libraryNameTag) {\n        libraryName = libraryNameTag.description;\n      }\n\n      libraryDesc = docs[0].description;\n    }\n\n    return {\n      name: libraryName,\n      description: this.parseMarkdown(libraryDesc)\n    };\n  };\n\n  /**\n   * Parses a comment.\n   *\n   * @param {Object} comment The comment to parse.\n   * @returns {Object?}\n   */\n  Autodoc.prototype.parseComment = function(comment) {\n    var value = comment.value;\n\n    // I think I'm going crazy? For some reason I was originally wrapping\n    // comments in /* and */ before parsing them with doctrine. Now it seems\n    // that was never necessary and, in fact, just introduced ugliness with\n    // CoffeeScript. So I'm completely reversing course, and REMOVING these\n    // strings instead of introducing them. Seems to fix the issue.\n    value = value.replace(/^\\s*\\/\\*|\\*\\/\\s*$/g, '');\n\n    try {\n      return this.commentParser.parse(value, { unwrap: true, lineNumbers: true });\n\n    } catch (e) {\n      this.errors.push({\n        stage: 'parsing comment',\n        line: comment.loc.start.line,\n        message: String(e.message || e)\n      });\n\n      return null;\n    }\n  };\n\n  /**\n   * Represents a single code example illustrating how a function works,\n   * including an expectation as well as an actual (relative) source location.\n   *\n   * @typedef {Object} ExampleInfo\n   * @public\n   * @property {number} id\n   * @property {number} relativeLine\n   * @property {number} absoluteLine\n   * @property {string} actual\n   * @property {string} actualEscaped\n   * @property {string} expected\n   * @property {string} expectedEscaped\n   */\n\n  /**\n   * A collection of {@link ExampleInfo} objects, with an optional block of\n   * setup code and some additional properties.\n   *\n   * @typedef {Object} ExampleCollection\n   * @public\n   * @property {string} code\n   * @property {string} highlightedCode\n   * @property {string} setup\n   * @property {Array.<ExampleInfo>} list\n   */\n\n  /**\n   * Produces a { setup, examples } object providing some examples of a function.\n   *\n   * @param {Object} doc\n   * @returns {ExampleCollection}\n   */\n  Autodoc.prototype.getExamples = function(doc, comment) {\n    var self = this,\n        exampleIdCounter = 1;\n\n    return this.parseCommentLines(doc, comment.lines, ['examples', 'example'], function(data) {\n      return {\n        code: data.content,\n        highlightedCode: self.highlightCode(data.content),\n        setup: self.compileSnippet(data.preamble),\n        list: Lazy(data.pairs).map(function(pair) {\n          // Snip out any leading 'var x = ' before the actual expression.\n          // Why? Because this is going to get injected into a template, and\n          // we don't want to have 'var result = var x = '.\n          //\n          // To be fair, there's probably a better approach. I'll leave figuring\n          // that out as an exercise to my future self.\n          var actual    = pair.left,\n              expected  = pair.right,\n              variable  = extractVar(pair.left) || 'actual',\n              statement = 'var ' + variable + ' = ' + removeVar(actual);\n\n          return {\n            id: exampleIdCounter++,\n            relativeLine: pair.lineNumber,\n            absoluteLine: comment.loc.start.line + data.lineNumber + pair.lineNumber,\n            actual: self.compileSnippet(actual),\n            actualEscaped: Autodoc.escapeJsString(actual),\n            expected: expected,\n            expectedEscaped: Autodoc.escapeJsString(expected),\n            variable: variable,\n            statement: statement\n          };\n        }).toArray()\n      };\n    });\n  };\n\n  /**\n   * Represents a single benchmark case.\n   *\n   * @typedef {Object} BenchmarkCase\n   * @public\n   * @property {number} caseId\n   * @property {string} impl\n   * @property {string} name\n   * @property {string} label\n   */\n\n  /**\n   * Represents a performance benchmark, which should illustrate a single piece\n   * of functionality with one or more *cases* to compare different\n   * implementations.\n   *\n   * @typedef {Object} BenchmarkInfo\n   * @public\n   * @property {number} id\n   * @property {string} name\n   * @property {Array.<BenchmarkCase>} cases\n   */\n\n  /**\n   * A collection of {@link BenchmarkInfo} objects, each of which illustrates a\n   * single piece of functionality with one or more cases each.\n   *\n   * @typedef {Object} BenchmarkCollection\n   * @public\n   * @property {string} code\n   * @property {string} highlightedCode\n   * @property {string} setup\n   * @property {Array.<BenchmarkInfo>} list\n   */\n\n  /**\n   * Produces a { setup, benchmarks } object providing some benchmarks for a function.\n   *\n   * @param {Object} doc\n   * @param {Object} comment\n   * @returns {BenchmarkCollection}\n   */\n  Autodoc.prototype.getBenchmarks = function(doc, comment) {\n    var self = this,\n        benchmarkCaseIdCounter = 1,\n        benchmarkIdCounter     = 1;\n\n    return this.parseCommentLines(doc, comment.lines, 'benchmarks', function(data) {\n      var benchmarks = Lazy(data.pairs)\n        .map(function(pair) {\n          var parts = divide(pair.right, ' - ');\n\n          return {\n            caseId: benchmarkCaseIdCounter++,\n            impl: self.compileSnippet(pair.left),\n            name: parts[0],\n            label: parts[1] || 'Ops/second'\n          };\n        })\n        .groupBy('name')\n        .map(function(cases, name) {\n          return {\n            id: benchmarkIdCounter++,\n            name: name,\n            cases: cases\n          }\n        })\n        .toArray();\n\n      return {\n        code: data.content,\n        highlightedCode: self.highlightCode(data.content),\n        setup: self.compileSnippet(data.preamble),\n        list: benchmarks,\n        cases: benchmarks.length > 0 ? benchmarks[0].cases : []\n      };\n    });\n  };\n\n  /**\n   * Does syntax highlighting on a bit of code.\n   */\n  Autodoc.prototype.highlightCode = function(code) {\n    var highlighter = this.highlighter;\n\n    try {\n      var highlightedCode = (highlighter && typeof highlighter.highlight === 'function') ?\n        highlighter.highlight(code, { mode: this.language }) :\n        code;\n\n      // Wrap each line in a <span> including the line number.\n      return Lazy(highlightedCode)\n        .split('\\n')\n        .map(function(line, i) {\n          return '<span class=\"line\" data-line-no=\"' + i + '\">' + line + '</span>';\n        })\n        .join('\\n');\n\n    } catch (e) {\n      this.errors.push({\n        stage: 'syntax highlighting',\n        line: '',\n        message: String(e.message || e)\n      });\n\n      return '<code>' + code + '</code>';\n    }\n  };\n\n  /**\n   * Parses Markdown + does syntax highlighting (maybe).\n   */\n  Autodoc.prototype.parseMarkdown = function(markdown) {\n    var self = this;\n\n    return this.markdownParser.parse(markdown, {\n      gfm: true,\n      highlight: function(code) {\n        return self.highlightCode(code);\n      }\n    });\n  };\n\n  /**\n   * Compiles just a little snippet of code.\n   */\n  Autodoc.prototype.compileSnippet = function(code) {\n    return trim(this.compiler.compile(code, { bare: true }));\n  };\n\n  /**\n   * Contains various representations (e.g., short, full) of the *name* of a\n   * function.\n   *\n   * @typedef {Object} NameInfo\n   * @property {string} name\n   * @property {string} shortName\n   * @property {string} longName\n   * @property {string} namespace\n   * @property {string} identifier\n   */\n\n  /**\n   * Takes, e.g., 'Foo#bar' and returns a { name, shortName, namespace,\n   * identifier} object.\n   *\n   * @public\n   * @param {string} name\n   * @param {FunctionInfo=} doc\n   * @returns {NameInfo}\n   *\n   * @examples\n   * Autodoc.parseName('Foo.prototype.bar').name           // => 'Foo#bar'\n   * Autodoc.parseName('Foo.prototype.bar').shortName      // => 'bar'\n   * Autodoc.parseName('Foo.Bar.prototype.baz').namespace  // => 'Foo.Bar'\n   * Autodoc.parseName('Foo.prototype.bar').identifier     // => 'Foo-bar'\n   * Autodoc.parseName('Foo.Bar.prototype.baz').identifier // => 'Foo-Bar-baz'\n   * Autodoc.parseName('Foo').name                         // => 'Foo'\n   * Autodoc.parseName('Foo').identifier                   // => 'Foo'\n   * Autodoc.parseName('Foo').namespace                    // => null\n   */\n  Autodoc.parseName = function(name, fn) {\n    var parts = name.split('.'),\n\n        // e.g., the short name for 'Lib.utils.func' should be 'func'\n        shortName = parts.pop(),\n\n        // keep the long name too, for e.g. regurgitating it back in a template\n        // (this is what we do w/ elevating private members)\n        longName = name,\n\n        // we'll say Foo.bar and Foo.prototype.bar both belong to the 'Foo'\n        // namespace\n        namespace = Lazy(parts).without('prototype').join('.');\n\n    // As a convention we'll reformat 'Class.prototype.method' as 'Class#method'\n    name = name.replace(/\\.prototype\\./, '#');\n\n    if (fn) {\n      // Actually, if this function is tagged @global, then it doesn't belong to\n      // a namespace.\n      if (Autodoc.hasTag(fn, 'global')) {\n        namespace = '';\n        name = shortName;\n\n      // On the other hand, if it's tagged @memberOf, then we want to use that\n      // tag for its explicit namespace. (We'll assume static members unless the\n      // @instance tag is present.)\n      } else if (Autodoc.hasTag(fn, 'memberOf')) {\n        namespace = Autodoc.getTagDescriptions(fn, 'memberOf')[0] || '';\n        name = namespace + ((fn && Autodoc.hasTag(fn, 'instance')) ? '#' : '.') +\n          shortName;\n      }\n    }\n\n    return {\n      name: name,\n      shortName: shortName,\n      longName: longName,\n      namespace: namespace || null,\n      identifier: name.replace(/[\\.#]/g, '-')\n    };\n  };\n\n  /**\n   * Simply determines whether a doc has a tag or doesn't.\n   *\n   * @public\n   * @param {Object} doc The doclet to check.\n   * @param {string} tagName The tag name to look for.\n   * @returns {boolean} Whether or not the doclet has the tag.\n   */\n  Autodoc.hasTag = function(doc, tagName) {\n    return !!Lazy(doc.tags).findWhere({ title: tagName });\n  };\n\n  /**\n   * Produces a string representing the signature of a function.\n   *\n   * @param {NameInfo} name\n   * @param {Array.<ParameterInfo>} params\n   * @returns {string}\n   */\n  Autodoc.getSignature = function(name, params) {\n    var formattedParams = '(' + Lazy(params).pluck('name').join(', ') + ')',\n        signature;\n\n    if (name.name === name.shortName) {\n      signature = 'function ' + name.shortName + formattedParams;\n    } else {\n      signature = name.namespace + '.' + name.shortName + ' = function' + formattedParams;\n    }\n\n    return signature + ' { /*...*/ }';\n  };\n\n  /**\n   * Represents an abstract left/right pair, which can be used e.g. as the basis\n   * for an {@link ExampleInfo}.\n   *\n   * @typedef {Object} PairInfo\n   * @property {number} lineNumber\n   * @property {string} left\n   * @property {string} right\n   */\n\n  /**\n   * @callback DataCallback\n   * @param {{preamble:string, pairs:Array.<PairInfo>}} data\n   * @returns {*}\n   */\n\n  /**\n   * Takes a doclet and a tag name (or list of tag names), then reads all of the\n   * lines from that tag and splits them across '=>', finally calling a callback\n   * on each left/right pair. (Does that make any sense? Whatever.)\n   *\n   * @param {Object} doc\n   * @param {string[]} source\n   * @param {string|string[]} tagNames\n   * @param {DataCallback} callback\n   * @returns {Array.<*>} An array of whatever the callback returns.\n   */\n  Autodoc.prototype.parseCommentLines = function(doc, source, tagNames, callback) {\n    var self     = this,\n        comments = Autodoc.getTags(doc, tagNames),\n        results  = [];\n\n    Lazy(comments).each(function(comment) {\n      var baseLine     = comment.lineNumber,\n          commentLines = comment.description.split('\\n'),\n          initialLines = [],\n          pairs        = [],\n          currentPair  = null,\n          previousPair = null;\n\n      Lazy(commentLines).each(function(line, i) {\n        // Allow multiline expectations as long as subsequent lines are indented\n        if ((/^\\s+/).test(line) && currentPair) {\n          currentPair.right += '\\n' + line;\n          currentPair.isMultiline = true;\n          return;\n        }\n\n        var pair = self.parsePair(line);\n\n        if (!pair && pairs.length === 0) {\n          initialLines.push(line);\n\n        } else if (pair) {\n          pair.lineNumber = i;\n\n          // Join pairs that actually take up two lines, like:\n          // actual();\n          // => expectation\n          if (!pair.left) {\n            // Allow actual value to be a multiline expression. As long as we\n            // don't swallow up any previous assertions, we'll walk backwards\n            // until encountering a blank line.\n            pair.left = [];\n            for (var line = i - 1; line >= 0 && (!previousPair || line > previousPair.lineNumber); --line) {\n              if (isBlank(commentLines[line])) {\n                break;\n              }\n              if (looksLikeComment(commentLines[line])) {\n                continue;\n              }\n\n              pair.left.unshift(pairs.length === 0 ? initialLines.pop() : commentLines[line]);\n            }\n\n            pair.left = pair.left.join('\\n');\n          }\n\n          pairs.push(pair);\n\n          if (currentPair) {\n            previousPair = currentPair;\n          }\n          currentPair = pair;\n\n        } else {\n          // Allow one final unindented line at the end of a multiline\n          // expectation.\n          if (currentPair) {\n            if (currentPair.isMultiline) {\n              currentPair.right += '\\n' + line;\n            }\n            previousPair = currentPair;\n          }\n          currentPair = null;\n        }\n      });\n\n      results.push(callback({\n        content: comment.description,\n        preamble: initialLines.join('\\n'),\n        lineNumber: baseLine,\n        pairs: pairs\n      }));\n    });\n\n    return results;\n  };\n\n  /**\n   * Gets the tags with the specified tag name(s).\n   *\n   * @param {Object} doc\n   * @param {string|string[]} tagNames\n   * @returns {Array.<Object>}\n   */\n  Autodoc.getTags = function(doc, tagNames) {\n    if (!(tagNames instanceof Array)) {\n      tagNames = [tagNames];\n    }\n\n    return Lazy(doc.tags)\n      .filter(function(tag) {\n        return Lazy(tagNames).contains(tag.title);\n      })\n      .toArray();\n  };\n\n  /**\n   * Gets the text descriptions from comment tags with the specified tag name(s).\n   *\n   * @param {Object} doc\n   * @param {string|string[]} tagNames\n   * @returns {Array.<string>}\n   */\n  Autodoc.getTagDescriptions = function(doc, tagNames) {\n    return Lazy(Autodoc.getTags(doc, tagNames))\n      .pluck('description')\n      .toArray();\n  };\n\n  /**\n   * Given a line like 'left // => right', parses this into a { left, right }\n   * pair. Trims leading and trailing whitespace around both parts. The '=>'\n   * part is optional.\n   *\n   * @public\n   * @param {string} line\n   * @returns {PairInfo|null}\n   *\n   * @examples\n   * var autodoc = new Autodoc({\n   *   exampleHandlers: [\n   *     { pattern: /^custom pattern$/ }\n   *   ]\n   * });\n   *\n   * autodoc.parsePair('foo(bar)//=>5')      // => { left: 'foo(bar)', right: '5' }\n   * autodoc.parsePair(' bar(baz) //=> 10 ') // => { left: 'bar(baz)', right: '10' }\n   * autodoc.parsePair('foo // => bar')      // => { left: 'foo', right: 'bar' }\n   * autodoc.parsePair('foo // bar')         // => { left: 'foo', right: 'bar' }\n   * autodoc.parsePair('// => 5')            // => { left: '', right: '5' }\n   * autodoc.parsePair('// bar')             // => null\n   * autodoc.parsePair('// custom pattern')  // => { left: '', right: 'custom pattern' }\n   * autodoc.parsePair('foo //')             // => null\n   * autodoc.parsePair('foo // \"http://example.com\"') // => { left: 'foo', right: '\"http://example.com\"'}\n   */\n  Autodoc.prototype.parsePair = function(line) {\n    var parts = this.splitAtComment(line);\n\n    if (!parts || !parts[1]) {\n      return null;\n    }\n\n    // The => is only optional for single-line pairs, unless there's a custom\n    // handler that matches the right-hand side.\n    if (!parts[0] && !/^\\s*=>/.test(parts[1])) {\n      if (!Lazy(this.exampleHandlers).any(function(handler) {\n        return handler.pattern.test(parts[1]);\n      })) return null;\n    } else {\n      parts[1] = parts[1].replace(/^\\s*=>\\s*/, '');\n    }\n\n    return {\n      left: parts[0],\n      right: parts[1]\n    };\n  };\n\n  /**\n   * Splits a line w/ a trailing '//' comment into, basically, the code part and\n   * the comment part.\n   *\n   * @public\n   * @param {string} line\n   * @return {Array.<string>}\n   *\n   * @example\n   * var autodoc = new Autodoc();\n   *\n   * autodoc.splitAtComment('foo // bar'); // => ['foo', 'bar']\n   * autodoc.splitAtComment('foo(\"//\") // bar'); // => ['foo(\"//\")', 'bar']\n   */\n  Autodoc.prototype.splitAtComment = function(line) {\n    // OK, here we go! We're going to read the sucker char-by-char until finding\n    // two consecutive slashes ('//') that are NOT inside a string! Whee!!!\n    var commentIndex = -1,\n        slashCount = 0,\n        stringState = null,\n        index = -1;\n\n    while (++index < line.length) {\n      if (commentIndex !== -1)\n        break;\n\n      switch (line.charAt(index)) {\n        case '/':\n          if (!stringState && (++slashCount === 2))\n            commentIndex = index - 1;\n          break;\n\n        case '\"':\n          if (!stringState)\n            stringState = '\"';\n          else if (stringState === '\"' && line.charAt(index - 1) !== '\\\\')\n            stringState = null;\n          break;\n\n        case \"'\":\n          if (!stringState)\n            stringState = \"'\";\n          else if (stringState === \"'\" && line.charAt(index - 1) !== '\\\\')\n            stringState = null;\n          break;\n\n        default:\n          slashCount = 0;\n      }\n    }\n\n    if (commentIndex === -1)\n      return null;\n\n    return [\n      trim(line.substring(0, commentIndex)),\n      trim(line.substring(commentIndex + 2))\n    ];\n  };\n\n  /**\n   * Produces a string representation of a type object.\n   *\n   * @param {Object} type\n   * @returns {string}\n   */\n  Autodoc.formatType = function(type) {\n    if (!type) { return '*'; }\n\n    switch (type.type) {\n      case 'NameExpression':\n        return type.name;\n\n      case 'AllLiteral':\n        return '*';\n\n      case 'NullLiteral':\n        return 'null';\n\n      case 'TypeApplication':\n        return Autodoc.formatType(type.expression) + '.<' + Lazy(type.applications).map(Autodoc.formatType).join('|') + '>';\n\n      case 'RecordType':\n        return '{' + Lazy(type.fields).map(function(field) {\n          return field.key + ':' + Autodoc.formatType(field.value);\n        }).join(', ');\n\n      case 'OptionalType':\n        return Autodoc.formatType(type.expression) + '?';\n\n      case 'UnionType':\n        return Lazy(type.elements).map(Autodoc.formatType).join('|');\n\n      case 'RestType':\n        return '...' + Autodoc.formatType(type.expression);\n\n      case 'FunctionType':\n        return 'function(' + Lazy(type.params).map(Autodoc.formatType).join(', ') + '):' + Autodoc.formatType(type.result);\n\n      case 'ArrayType':\n        return type.elements;\n\n      case 'NullableType':\n        return '?' + Autodoc.formatType(type.expression);\n\n      case 'NonNullableType':\n        return '!' + Autodoc.formatType(type.expression);\n\n      default:\n        throw 'Unable to format type ' + type.type + '!\\n\\n' + JSON.stringify(type, null, 2);\n    }\n  };\n\n  /**\n   * Represents a bunch of information about a *namespace*, which is either a\n   * function or an object with multiple members, forming one of the larger\n   * pieces of a library.\n   *\n   * @typedef {Object} NamespaceInfo\n   * @public\n   * @property {string} namespace\n   * @property {FunctionInfo} constructorMethod\n   * @property {Array.<FunctionInfo>} members\n   * @property {Array.<FunctionInfo>} privateMembers\n   * @property {Array.<FunctionInfo>} allMembers\n   * @property {boolean} hasExamples\n   * @property {boolean} hasBenchmarks\n   */\n\n  /**\n   * Finds all of the functions in a library belonging to a certain namespace\n   * and creates a {@link NamespaceInfo} object from each, with members sorted\n   * in a UI-friendly order.\n   *\n   * @public\n   * @param {Object.<string, Array.<FunctionInfo>>} docs\n   * @param {string} namespace\n   * @returns {NamespaceInfo}\n   */\n  Autodoc.createNamespaceInfo = function(docs, namespace) {\n    // Find the corresponding constructor, if one exists.\n    var constructorMethod = Lazy(docs)\n      .values()\n      .flatten()\n      .findWhere({ name: namespace });\n\n    // Get all the members that are part of the specified namespace, excluding\n    // the constructor (if applicable), and sort them alphabetically w/ so-called\n    // \"static\" members coming first.\n    var members = Lazy(docs[namespace])\n      .reject(function(doc) {\n        return doc.name === namespace;\n      })\n      .sortBy(function(doc) {\n        // Talk about hacky...\n        // This is how I've decided to put static methods first.\n        return (doc.isStatic ? 'a' : 'b') + doc.shortName;\n      })\n      .toArray();\n\n    // For templating purposes, it will also be useful to have a collection\n    // comprising ALL members, in this order:\n    //\n    // 1. constructor\n    // 2. static methods\n    // 3. instance methods\n    var allMembers = Lazy([constructorMethod])\n      .concat(members)\n      .compact()\n      .toArray();\n\n    // Private members can be elevated to some visible scope when running tests.\n    var privateMembers = Lazy(allMembers)\n      .filter('isPrivate')\n      .sortBy('name')\n      .toArray();\n\n    // Decorate these docs w/ a meaningful \"type\" (this is more useful than just\n    // a boolean flag, and it's easier to do here than in the template).\n    Lazy(allMembers).each(function(member) {\n      member.sectionType = member.isConstructor ? 'constructor' : 'method';\n    });\n\n    return {\n      namespace: namespace,\n      constructorMethod: constructorMethod,\n      members: members,\n      privateMembers: privateMembers,\n      allMembers: allMembers,\n      hasExamples: Lazy(allMembers).any('hasExamples'),\n      hasBenchmarks: Lazy(allMembers).any('hasBenchmarks'),\n      excludeFromDocs: (namespace === '[private]') || Lazy(allMembers).all('excludeFromDocs')\n    };\n  };\n\n  /**\n   * Replaces JsDoc references like '{@link MyClass}' with actual HTML links.\n   *\n   * @param {string} html\n   * @returns {string} The HTML with JsDoc `@link` references replaced by links.\n   *\n   * @examples\n   * Autodoc.processInternalLinks('{@link MyClass}') // => '<a href=\"#MyClass\">MyClass</a>'\n   */\n  Autodoc.processInternalLinks = function(html) {\n    return html.replace(/\\{@link ([^\\}]*)}/g, function(string, match) {\n      return '<a href=\"#' + match.replace(/[\\.#]/g, '-') + '\">' + match + '</a>';\n    });\n  };\n\n  /**\n   * Checks whether an AST node is a line like:\n   *\n   *     module.exports = Foo;\n   *\n   * @param {Object} node The AST node to check.\n   * @returns {string=} If `node` assigns some identifier to `module.exports`,\n   *     then the name of that identifier. Otherwise `null`.\n   */\n  Autodoc.getModuleExportsIdentifier = function(node) {\n    node = node.unwrap();\n\n    if (node.type !== 'AssignmentExpression') {\n      return null;\n    }\n\n    if (node.left.type !== 'MemberExpression') {\n      return null;\n    }\n\n    var object     = node.left.object,\n        property   = node.left.property,\n        identifier = node.right;\n\n    if (!Lazy([object, property, identifier]).all({ type: 'Identifier' })) {\n      return null;\n    }\n\n    if (object.name !== 'module' || property.name !== 'exports') {\n      return null;\n    }\n\n    return identifier.name;\n  };\n\n  /**\n   * Given an AST node representing some function and the associated library\n   * code, returns just the code for the function.\n   *\n   * @param {Object} node The AST node.\n   * @param {string} code The source code for the associated library.\n   * @return {string} Just the source code for the function itself.\n   */\n  Autodoc.getFunctionSource = function(node, code) {\n    var substring = String.prototype.substring.apply(code, node.range);\n    return unindent(substring);\n  };\n\n  /**\n   * Provides an escaped form of a string to facilitate dropping it \"unescaped\"\n   * (aside from this, of course) directly into a JS template. Basically,\n   * escapes single quotes, double quotes, newlines, and backslashes.\n   *\n   * @public\n   * @param {string} string\n   * @returns {string}\n   *\n   * @examples\n   * Autodoc.escapeJsString('foo')                      // => 'foo'\n   * Autodoc.escapeJsString(\"Hell's Kitchen\")           // => \"Hell\\\\'s Kitchen\"\n   * Autodoc.escapeJsString('Dan \"The Man\"')            // => 'Dan \\\\\"The Man\\\\\"'\n   * Autodoc.escapeJsString('line 1\\nline 2')           // => 'line 1\\\\nline 2'\n   * Autodoc.escapeJsString('foo\\\\bar')                 // => 'foo\\\\\\\\bar'\n   * Autodoc.escapeJsString('dir\\\\\"other dir\"\\\\Moe\\'s') // => 'dir\\\\\\\\\\\\\"other dir\\\\\"\\\\\\\\Moe\\\\\\'s'\n   */\n  Autodoc.escapeJsString = function(string) {\n    return string.replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n');\n  };\n\n  /**\n   * Removes leading and trailing whitespace from a string.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} The trimmed result.\n   *\n   * @examples\n   * trim('foo')                 // => 'foo'\n   * trim('  foo')               // => 'foo'\n   * trim('foo  ')               // => 'foo'\n   * trim('  foo  ')             // => 'foo'\n   * trim(' \\t\\n\\r foo \\r\\n\\t ') // => 'foo'\n   *\n   * @benchmarks\n   * trim('foo')        // no trimming necessary\n   * trim('   foo    ') // trimming necessary\n   */\n  function trim(string) {\n    return string.replace(/^\\s+/, '').replace(/\\s+$/, '');\n  }\n\n  /**\n   * Splits apart a camelCased string.\n   *\n   * @private\n   * @param {string} string The string to split.\n   * @returns {Array.<string>} An array containing the parts of the string.\n   *\n   * @examples\n   * splitCamelCase('fooBarBaz');      // => ['foo', 'bar', 'baz']\n   * splitCamelCase('Foo123Bar');      // => ['foo123', 'bar']\n   * splitCamelCase('XMLHttpRequest'); // => ['xml', 'http', 'request']\n   */\n  function splitCamelCase(string) {\n    var matcher  = /[^A-Z]([A-Z])|([A-Z])[^A-Z]/g,\n        tokens   = [],\n        position = 0,\n        index, match;\n\n    string || (string = '');\n\n    while (match = matcher.exec(string)) {\n      index = typeof match[1] === 'string' ? match.index + 1 : match.index;\n      if (position === index) { continue; }\n      tokens.push(string.substring(position, index).toLowerCase());\n      position = index;\n    }\n    \n    if (position < string.length) {\n      tokens.push(string.substring(position).toLowerCase());\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Converts a string like 'fooBar' to 'foo-bar'.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {string} The same string, but hyphenated rather than camelCased.\n   *\n   * @examples\n   * hyphenate('fooBarBaz');      // => 'foo-bar-baz'\n   * hyphenate('Foo123Bar');      // => 'foo123-bar'\n   * hyphenate('XMLHttpRequest'); // => 'xml-http-request'\n   */\n  function hyphenate(string) {\n    return splitCamelCase(string).join('-');\n  }\n\n  /**\n   * Converts a camelCased string to an acronym.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {string} An acronym (lower-case) comprising the first letter from\n   *     each part of the string.\n   *\n   * @examples\n   * acronym('fooBarBaz');      // => 'fbb'\n   * acronym('foo123Bar');      // => 'fb'\n   * acronym('XMLHttpRequest'); // => 'xhr'\n   */\n  function acronym(string) {\n    return splitCamelCase(string).map(\n      function(str) { return str.charAt(0); }).join('');\n  }\n\n  /**\n   * Splits a string into two parts on either side of a specified divider.\n   *\n   * @private\n   * @param {string} string The string to divide into two parts.\n   * @param {string} divider The string used as the pivot point.\n   * @returns {Array.<string>} The parts of the string before and after the\n   *     first occurrence of `divider`, or a 1-element array containing `string`\n   *     if `divider` wasn't found.\n   *\n   * @examples\n   * divide('hello', 'll')   // => ['he', 'o']\n   * divide('banana', 'n')   // => ['ba', 'ana']\n   * divide('a->b->c', '->') // => ['a', 'b->c']\n   * divide('foo', 'xyz')    // => ['foo']\n   * divide('abc', 'abc')    // => ['', '']\n   */\n  function divide(string, divider) {\n    var seam = string.indexOf(divider);\n    if (seam === -1) {\n      return [string];\n    }\n\n    return [string.substring(0, seam), string.substring(seam + divider.length)];\n  };\n\n  /**\n   * Unindents a multiline string based on the indentation level of the least-\n   * indented line.\n   *\n   * @private\n   * @param {string} string The string to unindent.\n   * @param {boolean} skipFirstLine Whether or not to skip the first line for\n   *     the purpose of determining proper indentation (defaults to `true`).\n   * @returns {string} A new string that has effectively been unindented.\n   *\n   * @examples\n   * unindent('foo\\n  bar\\n  baz');   // => 'foo\\nbar\\nbaz'\n   * unindent('foo\\n  bar\\n    baz'); // => 'foo\\nbar\\n  baz'\n   * unindent('foo\\n\\n  bar\\n  baz'); // => 'foo\\n\\nbar\\nbaz'\n   * unindent('foo\\n\\n  bar\\n baz');  // => 'foo\\n\\n bar\\nbaz'\n   */\n  function unindent(string, skipFirstLine) {\n    var lines     = string.split('\\n'),\n        skipFirst = typeof skipFirstLine !== 'undefined' ? skipFirstLine : true,\n        start     = skipFirst ? 1 : 0;\n\n    var indentation, smallestIndentation = Infinity;\n    for (var i = start, len = lines.length; i < len; ++i) {\n      if (isBlank(lines[i])) {\n        continue;\n      }\n\n      indentation = getIndentation(lines[i]);\n      if (indentation < smallestIndentation) {\n        smallestIndentation = indentation;\n      }\n    }\n\n    var result = [lines[0]]\n      .concat(\n        lines\n          .slice(1)\n          .map(function(line) { return decreaseIndent(line, smallestIndentation); })\n      )\n      .join('\\n');\n\n    return result;\n  }\n\n  /**\n   * Determines how much a line is indented.\n   *\n   * @private\n   * @param {string} line The line to look at.\n   * @returns {number} The number of spaces the line is indented.\n   *\n   * @examples\n   * getIndentation('');      // => 0\n   * getIndentation('  bar'); // => 2\n   */\n  function getIndentation(line) {\n    return line.match(/^(\\s*)/)[1].length;\n  }\n\n  /**\n   * Decreases the indentation of a line.\n   *\n   * @private\n   * @param {string} line The line whose indentation you want to decrease.\n   * @param {number} amount The number of spaces the given line's indentation\n   *     should be decreased.\n   * @returns {string} A new string with less indentation than the given one.\n   *\n   * @examples\n   * decreaseIndent('  foo', 2);   // => 'foo'\n   * decreaseIndent('    foo', 2); // => '  foo'\n   * decreaseIndent('', 2);        // => ''\n   */\n  function decreaseIndent(line, amount) {\n    return line.substring(amount);\n  }\n\n  /**\n   * Determines if a string is empty or consists only of whitespace.\n   *\n   * @private\n   * @param {string} string The string to check for blankness.\n   * @returns {boolean} Whether or not the string is blank.\n   *\n   * @examples\n   * isBlank('');             // => true\n   * isBlank('foo');          // => false\n   * isBlank('   ');          // => true\n   * isBlank(' \\n');          // => true\n   * isBlank(' \\t');          // => true\n   * isBlank(' \\r');          // => true\n   * isBlank('foo\\n  \\nbar'); // => false\n   */\n  function isBlank(string) {\n    return (/^\\s*$/).test(string);\n  }\n\n  /**\n   * Determines if a string looks like a JavaScript comment.\n   *\n   * @private\n   * @param {string} string The string to check.\n   * @returns {boolean} Whether or not the string looks like a JavaScript comment.\n   *\n   * @examples\n   * looksLikeComment('');             // => false\n   * looksLikeComment('foo');          // => false\n   * looksLikeComment('// foo');       // => true\n   * looksLikeComment('  // foo');     // => true\n   * looksLikeComment('foo // bar');   // => false\n   */\n  function looksLikeComment(string) {\n    return (/^\\s*\\/\\//).test(string);\n  }\n\n  /**\n   * Takes the first line of a string and, if there's more, appends '...' to\n   * indicate as much.\n   *\n   * @private\n   * @param {string} string The string whose first line you want to get.\n   * @returns {string} The first line of the string.\n   *\n   * @examples\n   * firstLine('foo');      // => 'foo'\n   * firstLine('foo\\nbar'); // => 'foo (...)'\n   */\n  function firstLine(string) {\n    var lineBreak = string.indexOf('\\n');\n\n    if (lineBreak === -1) {\n      return string;\n    }\n\n    return string.substring(0, lineBreak) + ' (...)';\n  }\n\n  /**\n   * Prepends each line in a block of text w/ line numbers, optionally\n   * highlighting a specific line.\n   */\n  function withLineNumbers(text, offset, offendingLine) {\n    if (typeof offendingLine !== 'number') {\n      offendingLine = NaN;\n    }\n\n    var lines = text;\n    if (typeof lines === 'string') {\n      lines = lines.split('\\n');\n    }\n\n    return lines.map(function(line, i) {\n      line = (i + offset) + ': ' + line;\n      if (i === (offendingLine - 1)) {\n        line = '\\x1B[31m' + line + '\\x1B[39m';\n      } else {\n        line = '\\x1B[90m' + line + '\\x1B[39m';\n      }\n      return line;\n    }).join('\\n');\n  }\n\n  /**\n   * Yes, removes the leading 'var' from a line. Leave me alone.\n   *\n   * @private\n   * @param {string} string With leading var.\n   * @returns {string} Without leading var.\n   *\n   * @examples\n   * removeVar('var foo = 5');  // => '5'\n   * removeVar('foo = \"var x\"') // => 'foo = \"var x\"'\n   * removeVar('var _foo = 8'); // => '8'\n   * removeVar('var $foo = 8'); // => '8'\n   * removeVar('var a, b = 5'); // => 'var a, b = 5'\n   */\n  function removeVar(string) {\n    return string.replace(/^\\s*var\\s*[\\w\\$]+\\s*=\\s*/, '');\n  }\n\n  /**\n   * Extracts the variable name declared with 'var' from a line, if present.\n   * TODO: Parse the line instead of doing this regex crap.\n   *\n   * @private\n   * @param {string} string With leading var.\n   * @returns {?string} Variable name, or null.\n   *\n   * @examples\n   * extractVar('var foo = 5');  // => 'foo'\n   * extractVar('foo = \"var x\"') // => null\n   * extractVar('var _foo = 8'); // => '_foo'\n   * extractVar('var $foo = 8'); // => '$foo'\n   * extractVar('var a, b = 5'); // => null\n   */\n  function extractVar(string) {\n    var name = string.match(/^\\s*var\\s*([\\w\\$]+)\\s*=\\s*/);\n    return name ? name[1] : null;\n  }\n\n  /**\n   * Checks if a string starts with a given prefix.\n   *\n   * @private\n   * @param {string} string\n   * @param {string} prefix\n   * @returns {boolean}\n   *\n   * @examples\n   * startsWith('foo', 'f');    // => true\n   * startsWith('foo', 'foo');  // => true\n   * startsWith('foo', 'fool'); // => false\n   * startsWith('foo', 'oo');   // => false\n   */\n  function startsWith(string, prefix) {\n    return string.lastIndexOf(prefix, 0) === 0;\n  }\n\n  /**\n   * Takes either a `{ parse }` object or an actual function and wraps it as a\n   * `{ parse }` object with an optional post-processing step.\n   */\n  function wrapParser(parser, postprocess) {\n    if (!parser) {\n      return null;\n    }\n\n    postprocess = postprocess || Lazy.identity;\n\n    var parseMethod = typeof parser === 'function' ?\n      parser :\n      parser.parse;\n\n    return {\n      parse: function() {\n        return postprocess(parseMethod.apply(parser, arguments));\n      }\n    };\n  }\n\n  /**\n   * Updates the HTML representing a function's signature by replacing the '...'\n   * with a link to the full source.\n   */\n  function insertSignatureLink(html, identifier) {\n    return html.replace('/*...*/', '<a class=\"reveal-source\" href=\"#source-' + identifier + '\">/*...*/</a>');\n  }\n\n  /**\n   * The default handlers defined for examples.\n   */\n  function exampleHandlers(customHandlers) {\n    return (customHandlers || []).concat([\n      {\n        pattern: /^(\\w[\\w\\.\\(\\)\\[\\]'\"]*)\\s*===?\\s*(.*)$/,\n        template: 'equality',\n        data: function(match) {\n          return {\n            left: match[1],\n            right: match[2]\n          };\n        }\n      },\n      {\n        pattern: /^(\\w[\\w\\.\\(\\)\\[\\]'\"]*)\\s*!==?\\s*(.*)$/,\n        template: 'inequality',\n        data: function(match) {\n          return {\n            left: match[1],\n            right: match[2]\n          };\n        }\n      },\n      {\n        pattern: /^instanceof (.*)$/,\n        template: 'instanceof',\n        data: function(match) {\n          return { type: match[1] };\n        }\n      },\n      {\n        pattern: /^NaN$/,\n        template: 'nan'\n      },\n      {\n        pattern: /^throws$/,\n        template: 'throws'\n      },\n      {\n        pattern: /^calls\\s+(\\w+)\\s+(\\d+)(?:\\s+times?)?$/,\n        template: 'calls',\n        data: function(match) {\n          return {\n            callback: match[1],\n            count: getCount(match[2])\n          };\n        }\n      },\n      {\n        pattern: /^calls\\s+(\\w+)\\s+(\\d+)\\s+times? asynchronously$/,\n        template: 'calls_async',\n        data: function(match) {\n          return {\n            callback: match[1],\n            count: getCount(match[2])\n          };\n        }\n      },\n      {\n        pattern: /^=~\\s+\\/(.*)\\/$/,\n        template: 'string_proximity',\n        data: function(match) {\n          return { pattern: match[1] };\n        }\n      },\n      {\n        pattern: /^=~\\s+\\[(.*),?\\s*\\.\\.\\.\\s*\\]$/,\n        template: 'array_inclusion',\n        data: function(match) {\n          return { elements: match[1] };\n        }\n      },\n      {\n        pattern: /^one of (.*)$/,\n        template: 'array_membership',\n        data: function(match) {\n          return { values: match[1] };\n        }\n      },\n      {\n        pattern: /^=~\\s+\\[(.*)\\]$/,\n        template: 'array_proximity',\n        data: function(match) {\n          return { elements: match[1] };\n        }\n      },\n      {\n        pattern: /^\\[(.*),?\\s*\\.\\.\\.\\s*\\]$/,\n        template: 'array_head',\n        data: function(match) {\n          return { head: match[1] };\n        }\n      },\n      {\n        pattern: /^\\[\\s*\\.\\.\\.,?\\s*(.*)\\]$/,\n        template: 'array_tail',\n        data: function(match) {\n          return { tail: match[1] };\n        }\n      },\n      {\n        pattern: /\\{([\\s\\S]*),?[\\s\\n]*\\.\\.\\.[\\s\\n]*\\}/,\n        template: 'object_proximity',\n        data: function(match) {\n          return { properties: match[1] };\n        }\n      }\n    ]);\n  }\n\n  /**\n   * Very simple word-to-number converter.\n   *\n   * @private\n   * @examples\n   * getCount('one');   // => 1\n   * getCount('once');  // => 1\n   * getCount('twice'); // => 2\n   */\n  function getCount(word) {\n    switch (word.toLowerCase()) {\n      case 'one':\n      case 'once':\n        return 1;\n\n      case 'two':\n      case 'twice':\n        return 2;\n\n      case 'three':\n      case 'thrice':\n        return 3;\n\n      case 'four':\n        return 4;\n\n      case 'five':\n        return 5;\n\n      case 'six':\n        return 6;\n\n      case 'seven':\n        return 7;\n\n      case 'eight':\n        return 8;\n\n      case 'nine':\n        return 9;\n\n      case 'ten':\n        return 10;\n    }\n\n    return word;\n  }\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Autodoc;\n\n  } else {\n    context.Autodoc = Autodoc;\n  }\n\n}(typeof global !== 'undefined' ? global : this));\n","/home/travis/build/npmtest/node-npmtest-autodoc/node_modules/autodoc/resources/javascripts/utils.js":"/**\n * Formats a number by adding commas as the thousands separator and truncating\n * decimal part to 3 places (arbitrary decision on my part).\n *\n * @global\n * @param {number} number\n * @returns {string}\n */\nthis.formatNumber = function(number) {\n  var wholeAndDecimal = String(number.toFixed(3)).split('.'),\n      whole           = wholeAndDecimal[0],\n      parts           = [],\n      separatorCurr   = whole.length - 3,\n      separatorPrev;\n\n  while (separatorCurr > 0) {\n    parts.unshift(whole.substring(separatorCurr, separatorPrev));\n    separatorPrev = separatorCurr;\n    separatorCurr -= 3;\n  }\n\n  if (separatorCurr <= 0) {\n    parts.unshift(whole.substring(0, separatorPrev));\n  }\n\n  return parts.join(',') + '.' + wholeAndDecimal[1];\n};\n\n/**\n * Appends a bunch of whitespace to the end of a string to get it to a desired\n * length. Has no effect if the string exceeds the specified length to begin\n * with.\n *\n * @global\n * @param {string} str The string to pad.\n * @param {number} length The desired length of the string.\n * @returns {string} The string with its fresh new white padding.\n *\n * @examples\n * padRight('foo', 5) // => 'foo  '\n * padRight('', 5)    // => '     '\n * padRight('foo', 2) // => 'foo'\n */\nthis.padRight = function(str, length) {\n  while (str.length < length) {\n    str += ' ';\n  }\n  return str;\n};\n"}